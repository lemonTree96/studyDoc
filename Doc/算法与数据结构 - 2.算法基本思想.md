@[toc] 
***
### 三、算法基本思想
&emsp; &emsp;在算法问题中，重要的是对问题的理解和思考，从而选取合适的算法。面对一个问题，存在不同的结题思路，如何选取一个合适的算法就需要对各个算法的本质进行深入的了解。
&emsp; &emsp;在练习算法的过程中，一定要戒掉Baidu和Google，这是个痛苦的过程，但也是成功的必经之路。否则就会成为面向博客的编程。
####  0. 算法时间复杂度计算
&emsp; &emsp;算法的时间复杂度是一个函数，它定性描述该算法的运行时间，时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。
##### 0.1 数据规模的概念
&emsp; &emsp;程序的运行时间与算法的时间复杂度相关，也和数据规模有关。一个合适的程序需要根据不同的数据规模选取不同时间复杂度的算法。
&emsp; &emsp;如果想在1s内解决问题：
&emsp; &emsp;&emsp; &emsp;① O($n^2$)的算法可以处理$10^4$级别的数据；
&emsp; &emsp;&emsp; &emsp;② O($n$)的算法可以处理$10^8$级别的数据；
&emsp; &emsp;&emsp; &emsp;③ O($nlogn$)的算法可以处理$10^7$级别的数据；
##### 0.2 常见程序的算法复杂度分析
&emsp; &emsp;在计算程序性能时，有几个注意事项：
&emsp; &emsp;① 在计算程序性能时，虽然经常化简为最高项，如$2N^2+cN $ ~~$2N^2$，但有时我们也不能忽略常数项，特别的当常数项很大时，如c=$10^6$
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200330110246434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)
##### 0.3 提高程序的性能
&emsp; &emsp;要提高程序的性能，就是降低或稳定程序的时间复杂度，一般从两个方面进行：
&emsp; &emsp;**① 处理对于输入的依赖**：程序计算的目的就是找到输入集合的性质，因此如果我们能够在集合中找到其性质，就可以使用经典的数学分析来简化程序处理对输入的依赖。
&emsp; &emsp;**② 对最坏情况下性能的保证**：保证程序的性能下限。
&emsp; &emsp;**③ 随机化算法**：尽快能的保证算法的随机性。如对随机算法的改进。

***
####  1. 排序思想
&emsp; &emsp;排序思想是一个"古老而经典"的解决问题的方法。排序的依据是关键字之间的大小关系。
&emsp; &emsp;常见的排序算法如下图所示：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200223152854438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
##### 1.1 排序的概念
&emsp; &emsp;**<u>Q1. 什么是排序的稳定性？**</u>
&emsp; &emsp;&emsp; 假设`ki=kj (i≠j)`，且在排序前的序列中`i>j`，若排序后的序列中`i>j`，则这个排序是稳定的。若排序后的序列中`i<j`，则这个排序是不稳定的。排序算法的稳定性能够保证在多标签的数据中，保证原始标签排序的情况下，实现第二个标签的排序。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200427230047446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>

&emsp; &emsp;**<u>Q2. 何为内排序与外排序 ？**</u>
&emsp; &emsp;&emsp; 内排序是在排序过程中，待排序的所有记录全部放置在内存当中。外排序是由于排序记录个数太多，不能全部放在内存当中，在排序过程中需要多次内外存的数据交换。

&emsp; &emsp;**<u>Q3. 如何提高排序算法的性能 ？**</u>
&emsp; &emsp;&emsp; 1. 时间性能：排序最主要的操作是**比较**和**移动**，当这两个操作的时间性能提高了，整个排序算法的时间性能就会提高。
&emsp; &emsp;&emsp;2. 辅助空间：在排序过程中，有时会需要额外的空间来存放临时数据。

&emsp; &emsp;**<u>Q4. 比较类排序与非比较类排序区别 ？**</u>
&emsp; &emsp;&emsp;1.比较类排序是基于元素之间的比较来进行排序的，而非比较累不是基于元素比较，而是利用数组下标来确定元素的正确位置。
&emsp;&emsp;&emsp;2. 非比较类排序是一种通过空间来换取时间的排序方式。
##### 1.2 常见的排序方法
 💗 **1.2.1 冒泡排序**
&emsp; &emsp;冒泡排序是一种交换排序，其思想上是：**两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。** 每次循环会将**最小值**“冒泡”到顶端。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313162704592.gif)</div>

```
vector<int> Sorf::bubbleSorf(vector<int> &data){
    bool flag=true;   //添加哨兵，当序列为2,1,3,4,5,6,7,8,9时可减少循环
    for(int i=0;i<data.size() && flag;i++){     
        flag=false;  //如果其中一轮循环过后flag=false，说明排序完成，不会再次进入循环
        for(int j=data.size()-1;j>=i;j--)     //从最后一位向前循环到第i位，前i位是排好序的元素
            if(data[j]<data[j-1]){     //对相邻的两两元素进行比较
                swap(data[j],data[j-1]);    //交换元素
                flag=true;
            }               
    }
    return data;
}
```
 💗 **1.2.2 选择排序**
&emsp; &emsp;选择排序的思想是：**通过`n-1`次关键字间的比较，从`n-i+1`个记录中选出关键字最小的记录，并和第`i(1≤i≤n)`个记录交换。**
&emsp; &emsp;对于长度为N的数组，选择排序需要$N^2/2$次比较和N次交换。**选择排序存在两个特点:**
&emsp; &emsp;&emsp;① 运行时间与输入无关；
&emsp; &emsp;&emsp;② 选择排序的数据移动是最少的，数据比较是最多的。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313213453355.gif)</div>

```
vector<int> Sorf::selectSorf(vector<int> &data){
    int min;
    for(int i=0;i<data.size();i++){
        min=i;
        for(int j=i+1;j<data.size();j++){    //在i+1到data.size()范围内选择最小的元素
            if(data[min]>data[j])
                min=j;	//找到最小值
        }
        swap(data[min],data[i]);
    }
    return data;
}
```
 💗 **1.2.3 插入排序**
&emsp; &emsp;插入排序的算法思路是：**将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。**
&emsp; &emsp;**插入排序的特点如下**：
&emsp; &emsp;&emsp;① 插入排序所需时间取决于输入元素的初始顺序，当一个接近有序的数组进行排序，则效率很高。
&emsp; &emsp;&emsp;② 插入排序对某些类型的非随机数组很有效。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031322020414.gif)</div>
```
vector<int> Sorf::insertSorf(vector<int> &data){
    for(int i=1;i<data.size();i++){   
        if(data[i]<data[i-1]){	  //当前元素小于排序后的最后一个元素
            int current=data[i];   //保存当前元素，用于后边的交换
            int j;
            for(j=i-1;data[j]>current && j>-1;j--)   //在排好序的元素中进行遍历，插入保存的元素
                data[j+1]=data[j];
            data[j+1]=current;
        }
    }
    return data;
}
```
 💗 **1.2.4 希尔排序**
&emsp; &emsp;希尔排序是对插入排序的改进。希尔排序的算法思路是：使数组中任意间隔为h的元素都是有序的。首先将`m`个元素通过“增量`n1`”分割成`p1=m/n1`个组，**每个组内用插入排序法进行排序**，保证元素的局部有序。然后减少“增量`n2=n1/2`”为,继续分割`p2=m/n2`,用插入法排序。直到分组减少为1。
&emsp; &emsp;希尔排序的最好情况是，数据已经排好序，此时无论间隔h为多少，都不需要交换元素。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313223929991.gif)</div>
```
vector<int> Sort::shellSort(vector<int> &data){
    int increment=data.size();
    while(increment>1){
        increment=increment/2;    //增量序列
        for(int i=increment;i<data.size();i++){    //插入排泄算法
            if(data[i]<data[i-increment]){
                int current=data[i];
                int j;
                for(j=i-increment; j>-1 && current<data[j];j-=increment)
                    data[j+increment]=data[j];
                data[j+increment]=current;
            }    
        }
    }
    return data;
}
```
 💗 **1.2.5 基于堆的排序** - 优先队列的实现原理
&emsp; &emsp;▶ **堆排序简介**
&emsp; &emsp;在上述的排序方法中，通过排序会将所有的元素按大小进行排列。但是，有时我们不需要集合中所有的元素全部有序，或者不一定一次就将所有元素排序，我们可能需要每次只处理集合中最大的或最小的元素。此时就需要基于堆的排序。
 &emsp; &emsp;首先需要说明，所谓的堆排序，其本质是利用堆来得到最大元素或最小元素进行依次输出的方式。
 &emsp; &emsp;▶ **堆排序原理**
&emsp; &emsp;堆排序是对于**简单选择排序**的改进。在很多文章中看到说堆是一种完全二叉树，其实并不是。**堆是一种利用完全二叉树的结构及其性质一维数组**，<font color=orange>注意，为了使该一维数组能够利用完全二叉树的性质，数组中索引0(vec[0])是不放入任何元素的。</font>
&emsp; &emsp;堆可以分为大顶堆和小顶堆，但无论大顶堆还是小顶堆，<font color=orange>根节点一定是堆中所有结点最大(小)者。</font>：
&emsp; &emsp;大顶堆：完全二叉树的每个结点的值都<font color=orange>大于或等于</font>其左右孩子结点的值，称为大顶堆；
&emsp; &emsp;小顶堆：每个结点的值都<font color=orange>小于或等于</font>其左右孩子结点的值，称为小顶堆。 因此结点有如下关系：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224326651.png)</div>
&emsp; &emsp;同时又有完全二叉树的性质：对第`I`个结点，其父节点为`I/2`，其左节点为`2I`，其右节点为`2I+1`。若`2I>N`则无左节点，若`2I+1>N`则无右节点。
&emsp; &emsp;根据堆的性质，其算法思想为： <font color=green>将待排序的序列构成一个大顶堆，此时整个序列的最大值就是堆顶的根节点，将其与堆数组的末尾元素交换，将剩余的n-1个序列重新构成一个堆，往复执行就能得到一个有序序列。堆的时间复杂度为O(nlogn)</font><div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200223152659590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
```
vector<int> Sorf::heapSorf(vector<int> &data){  
    for(int i=data.size()/2;i>0;i--){      //从完全二叉树中最大的根节点(如上图为节点4)开始，遍历每个根节点(非叶子结点)
        heapAdjust(data,i,data.size());   //将原序列变成大顶堆，生成大顶堆后，序列中最大的元素在数组的最前边
    }
    for(int i=data.size();i>0;i--){  
        swap(data[1],data[i]);    //将大顶堆的跟节点交换到堆数组的最后一位
        heapAdjust(data,1,i-1);  //调整大顶堆，使剩下序列中较大的一位位于根节点
    }
    return data;
}
//data：元素序列   s:当前需要调整的节点号   len:当前未排序节点的长度
void heapAdjust(vector<int> &data,int s,int len){   //对单个根节点s与子节点进行调整   如：		3(s)
	 																					2(j)       1(j++)
	int temp=data[s];
	for(int j=s*2;j<=len;j*=2){   //s为根节点，2*s为根节点的左节点
		if(j<len && data[j]<data[j+1])  //若j是最后一个节点，则会j=len，否则说明该根节点还有右节点。
			j++;	//此时j=2*s+1，是完全二叉树最后一个根节点的右节点
		if(temp>=data[j])    //判断根节点与其子节点的值，若子节点>根节点，则交换。否则退出循环。当前根节点调整完毕
			break;
		data[s]=data[j];
		s=j;
	}
	data[s]=temp;
}
```
&emsp; &emsp;▶ **堆排序的优缺点如下：**
&emsp; &emsp; 优点：
&emsp; &emsp;  &emsp;① 堆排序的时间复杂度很稳定，其最坏情况为O(nlogn)。
&emsp; &emsp;  &emsp;② 堆排序能够以nlogn级别的时间运用在动态场景中。
&emsp; &emsp; 缺点：
&emsp; &emsp;  &emsp;堆排序在排序过程中，元素的移动距离过大，无法利用缓存(这是因为堆排序每次循环的步长很大，降低了程序的空间局部性，使缓存的命中率降低，从而降低了程序的性能)，数组元素很少和相邻的其他元素进行比较，因此缓存命中率次数远高于快速排序，归并排序。
&emsp; &emsp;▶ **优先队列 -- 基于堆的原理**
&emsp; &emsp;所谓优先队列ADT，就是元素被赋予**优先级**。<font color=green>在出队时，出队顺序是按照优先级大小进行出队。</font>优先队列分为**最大优先队列**和**最小优先队列**。
&emsp; &emsp; <u>**Q1. 优先队列有什么作用 ？**</u>
&emsp; &emsp; 由于优先队列出队时有顺序，因此<font color=orange>当在元素集合中寻找最小或最大元素时</font>，可以使用优先队列来完成。
💗 **1.2.6 归并排序**
&emsp; &emsp;归并排序利用**分治**的思想： <font color=green>假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，重复，直到得到一个长度为n的有序序列为止。归并排序的时间复杂度为O(nlogn).</font>
&emsp;&emsp;归并排序特点如下：
&emsp;&emsp;&emsp;① 对任意长度为`N`的数组，排序所需时间和`nlogn`成正比；但它所需的额外空间和`N`成正比。
&emsp;&emsp;&emsp;② 在归并的合并过程中，对于左右两个子数组，若有`a[i]>b[j]`，则对于`a`子数组从`[i-mid`]均大于`b[j]`，可以利用此特点来计算序列中的**逆序列**的个数。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428144616826.png)</div>&emsp; &emsp;通常情况下，在归并过程中分为两种情况，一种是利用一个辅助空间来进行数据的归并，另一种是直接进行原地数据归并。
&emsp; &emsp;<font color=green>**1. 利用辅助空间进行数据归并**</font>
&emsp;&emsp; 归并过程如下图所示：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200313231147459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
```cpp
//归并排序的基本方法
vector<int> mergeSort(vector<int> &vec) {
	vector<int> temp(vec.size(),0);
	sort(vec, 0, vec.size()-1, temp);
	return vec;
}
void merge(vector<int> &vec, int left, int mid, int right,vector<int> &merged) {
	int i = left, j = mid + 1;
	int t = 0;
	while (i <= mid && j <= right) {   //依次比较[left,mid]和[mid+1,right]，较小的值放入merged中
		if (vec[i] < vec[j])
			merged[t++] = vec[i++];
		else
			merged[t++] = vec[j++];    
	}
	while (i <= mid)
		merged[t++] = vec[i++];
	while (j <= right)
		merged[t++] = vec[j++];
	t = 0;
	while (left <= right)    //这里注意，一定要将合并后的数据更新到原数组中，否则，原数组的排序没有变化，会使递归重复进行
		vec[left++] = merged[t++];
}
void sort(vector<int> &vec, int left, int right,vector<int> merged) {
	if (left < right) {
		int mid = (right - left) / 2 + left;
		sort(vec, left, mid, merged);  //[left,mid]  左半边排序
		sort(vec, mid+1, right, merged); //(mid,right]  右半边排序
		merge(vec, left, mid, right, merged);   //合并左半边和右半边
	}
}
```
&emsp; &emsp;<font color=green>**2. 原地进行数据归并**</font>
&emsp; &emsp; 归并过程如下图所示:<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080421384741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
```cpp
void swap(vector<int> &vec,int first,int second){
    int temp=vec[first];
    vec[first]=vec[second];
    vec[second]=temp;
}
void reverse(vector<int> &vec,int start,int end){
    while(start<end){
        swap(vec,start++,end--);
    }
}
void exchange(vector<int> &vec,int left,int mid,int right){
    reverse(vec,left,mid);
    reverse(vec,mid+1,right);
    reverse(vec,left,right);
}
void merge_first(vector<int> &vec,int left,int mid,int right){
    int i=left;
    int j=mid+1;

    while(i<=mid && j<=right){
        while(i<=mid && vec[i]<=vec[j])  //对第一个数组，找到第一个大于vec[j]的下标
            ++i;      //[0,i)是整个数组中的最小值集合

        // [left...i...mid | old...j...right]
        int old=j;  //保存第二个数组的起始位
        while(j<=right && vec[j]<vec[i]){  //对第二个数组，找到第一个大于vec[i]的下标
            ++j;  // [i,old-1)>[old,j)>[0,i)
        }
        exchange(vec,i,old-1,j-1); //交换[old,j)与[i,old-1)的数据
        i+=(j-old);
    }
}
void splitDown(vector<int> &vec,int left,int right){  //自顶向下的归并
    if(left<right){
        int mid=left+(right-left)/2;
        splitDown(vec,left,mid);
        splitDown(vec,mid+1,right);
        merge_first(vec,left,mid,right);  
    }
}

vector<int> mergeSort(vector<int> &vec){
    splitDown(vec,0,vec.size()-1);
    return vec;
} 
```
&emsp;&emsp;●  归并排序优化：
&emsp;&emsp;在上面基本方法的基础上，归并排序有三个方面实现优化：
&emsp;&emsp;&emsp;**1. 对小规模的子数组使用插入排序**：在小规模子数组中，频繁的递归调用会降低算法的性能，因此在小规模的子数组可以选择用插入排序来替代。
&emsp;&emsp;&emsp;**2. 测试数组是否已经有序**：在递归分解子数组的过程中，数组被分为`[left,mid],(mid,right]`两部分，且每一部分都是有序的，如果此时`vec[mid]<vec[mid+1]`，则不需要进行归并了。
&emsp;&emsp;&emsp;**3.不将元素复制到辅助数组中**：将数据从输入数组排序到辅助元素(不是复制)，可以节省元素复制到辅助数组的时间但不会节省空间)。
💗 **1.2.7 快速排序**
 &emsp; &emsp;快速排序也是基于**分治**的思想，其步骤为：<font color=green>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，达到整个序列有序。</font> 这样的关键字称为<font color=blue>**枢轴**</font>
&emsp; &emsp;因此，快速排序法主要分为三步：
&emsp;&emsp;&emsp;**Step1:** 从元素序列中求取枢轴，并对元素进行交换排列，并返回计算后的枢轴的位置。
&emsp;&emsp;&emsp;**Step2:** 对序列左端到枢轴`[left,pivotKey-1]`进行排序；
&emsp;&emsp;&emsp;**Step3:** 对序列从枢轴到右端`[pivotKey+1,right]`进行排序。

&emsp; &emsp;**<u>Q1. 快速排序与归并排序都是基于分治思想，两者有什么区别？**</u>
&emsp;&emsp;&emsp;**①** 归并排序是将数组分成两个子数组分别排序，然后将有序的子数组归并；快速排序是当两个子数组都有序时整个数组就有序了。
&emsp;&emsp;&emsp;**②** 归并排序的递归调用发生在处理整个数组之前；快速排序的递归调用发生在处理整个数组之后
&emsp;&emsp;&emsp;**③** 归并排序中，一个数组被等分为两半；快速排序中，数组切分的位置(枢轴)取决于数组的内容。

&emsp;&emsp;▶ 快速排序特点如下：
&emsp;&emsp;&emsp;① <font color=red>快速排序空间复杂度为O(logn)。在最优的情况下时间复杂度为O(nlogn)，在最坏情况下(待排序序列为正序或逆序，数据重重复元素太多)，时间复杂度为O(n^2)</font>
&emsp;&emsp;&emsp;② 快速排序在切分不平衡的时候会导致极为抵消。
&emsp;&emsp;&emsp;③ 快速排序最多需要$N^2/2$次比较，当数组是随机排列是能够预防这种情况。

&emsp;&emsp;▶ 快速排序基本思想：
&emsp; &emsp;例如序列{50,10,90,30,70,40,80,60,20}第一次计算枢轴结果如下：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200422213915741.png)</div>
```cpp
vector<int>quickSort(vector<int>&vec){
	sortQ(vec,0,vec.size()-1);
	return vec;
}
int partition(vector<int>&vec,intleft,intright){
	int pivotKey=vec[left];
	int i=left;
	int j=right+1;
	while(i<j){
		while(vec[++i]<pivotKey)
			if(i==right)
				break;
		while(vec[--j]>pivotKey)
			if(j==left)
				break;
		if(i>=j)
			break;
		swap(vec[i],vec[j]);  //将小于pivotKey的与大于pivotKey的互换位置
	}
	swap(vec[left],vec[j]);  //交换枢轴与中间位置
	return j; //返回调整后的枢轴位置
}
void sortQ(vector<int>&vec,intleft,intright){
	if(left>=right)
		return;
	int	pivotKey=partition(vec,left,right);  //首先对原数组进行调整，得到调整后的枢轴的位置
	sortQ(vec,left,pivotKey-1); //递归调整枢轴左边的元素
	sortQ(vec,pivotKey+1,right); //递归调整枢轴右边的元素
}

```
&emsp; &emsp;在枢轴计算的方面，通常有三种方法：左右指针法，挖坑法和前后指针法。
&emsp; &emsp;① 左右指针：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423121610495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)
&emsp; &emsp;② 挖坑法：相比左右指针，减少了交换的次数。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423174559109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)
&emsp; &emsp;③ 前后指针法：

&emsp;&emsp;● 快速排序的优化：
&emsp; &emsp;在上面基本方法的基础上，快速排序算法有三个方面进行优化：
&emsp; &emsp;<font color=green>※ 1.  优化选取枢轴</font>
&emsp; &emsp;在上述的程序中，可以发现其枢轴是固定选择序列第一个数得到的，当待排序序列为正序或倒序时，会造成快速排序效率很低。**只有当枢轴选取序列的<font color=blue>中位数</font>时，快速排序的效率会很好**。常见的求取近似中位数的方法如下：
&emsp; &emsp;① 三数取中
&emsp; &emsp;三数取中就是取三个关键字，先进行排序，将中间数作为枢轴，一般是取左端，右端和中间三个数，也可以随机选取，然后选取三个数的中间大小的数。
```cpp
int midthrid(vector<int> &data,int start,int tail){   //三数取中选择枢轴  
	int m=(tail-start)/2+start;   //中间数
	if(data[start]>data[tail])
		swap(data[start],data[tail]);
	if(data[m]>data[tail])
		swap(data[m],data[tail]);
	if(data[m]>data[start])
		swap(data[m],data[start]);
	return data[start];   //返回枢轴元素
}
```

&emsp; &emsp;② 九数取中
&emsp; &emsp;九数取中就是在序列中分三次取样，每次取三个数，三个数中各取中数，然后在三个中数中再取中数作为枢轴。
&emsp; &emsp;<font color=green>※ 2.  切换到插入排序</font>
&emsp; &emsp;由于快速排序是通过递归来实现的，对于小数组，快速排序比插入排序慢。因此，在排序小数组时应该切换到插入排序。

```cpp
if(left>=right)		   if(left+M>=right){   //M为小数组的长度，根据情况自主设定
	return;      =>		 insertSort();
						 return;
					   }
```
&emsp; &emsp;<font color=green>※ 3. 优化不必要的交换</font>
&emsp; &emsp;在快速排序中在查找枢轴的过程中，需要数据多次交换。减少不必要的交换可以提高效率。如上述例子，关键字50变换为1-9-3-6-5，其中的9，3，6是不必要的变换。可以省略。 左右指针法变为挖坑法。
&emsp; &emsp;<font color=green>※ 4.  优化递归操作</font>
&emsp; &emsp;大量的递归对性能有一定影响，减少递归会大大提高性能。
```cpp
void sortQ(vector<int>&vec,intleft,intright){
	if(left>=right)
		return;
	int	pivotKey=partition(vec,left,right);  //首先对原数组进行调整，得到调整后的枢轴的位置
	sortQ(vec,left,pivotKey-1); //递归调整枢轴左边的元素
	//sortQ(vec,pivotKey+1,right); //递归调整枢轴右边的元素
	left=pivotKey+1;
}
```
💗 **1.2.8 三路快速排序**
&emsp; &emsp;快速排序虽然可以快速的实现排序，但是快速排序是不稳定的，当数据中出现大量的重复元素就会使时间复杂度从**O(logn)**变为**O(n^2)**。<font color=green>其原因是：快速排序只对大于枢轴和小于枢轴的进行排序，而等于枢轴的默认划分到了大于枢轴的那一部分，使得产生了大量重复的排序。</font>
&emsp; &emsp;基于这个问题，提出了三路快速排序，三路快速排序利用基准点V与数组的两端，将数组分为三部分：`[l,less]<V`，`[less+1,great-1]=V`，`[great,r]>V`。具体步骤如下：
&emsp; &emsp;① 首先以首个元素作为基准点V，索引`i`为遍历索引，`less`表示<V的最大索引，`great`为>V的最小索引。
&emsp; &emsp;② 当`i`指向的元素等于V时，则`i+1`
&emsp; &emsp;③ 当`i`指向的元素小于V时，将`less+1`处的值与当前元素进行交换，然后`less+1`,`i+1`
&emsp; &emsp;④ 当`i`指向的元素大于V时，将`great-1`处的元素与当前元素交换，然后`great-1`
&emsp; &emsp;⑤ 当`i==great`时，说明区间已经分区完毕，形成了想要的三个区间,小于V，等于V，大于V。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200319224312909.gif)</div>
```cpp
void quickSort3(vector<int> &data,int l,int r){
    if (l >= r)
        return;
   // int v = data[l];   //当前比较值
    int v=data[l+rand()%(r-l)];  //当初始值是随机选取的，此时的排序为随机快排
    int less=l-1; 		//data[l...less]<v
    int great=r+1;		//data[great...r]>v
    int i=l;    //data[l...less]<v, data[less+1...great-1]=v, data[great...r]>v
    while(i < great){
        if (data[i] > v){
            swap(data[i], data[great-1]);
            great--;
        }
        else if (data[i] == v){
            i++;
        }
        else{
            swap(data[i], data[less + 1]);
            less++;
            i++;
        }
    }
    quickSort3(data, l, less);
    quickSort3(data, great, r);
}
vector<int> Sort::threeRoadQuickSort(vector<int> &data){
    quickSort3(data,0,data.size()-1);
    return data;
}
```
💗 **1.2.9 计数排序**
&emsp; &emsp;计数排序是非比较类排序，利用数组下标来确定元素的正确位置。计数排序适用一定范围的整数排序，在取址范围不大的情况下，其性能由于比较类排序。计数排序的时间复杂度为 O(n+k)，空间复杂度为O(n+k).,k为申请的额外空间的大小
&emsp; &emsp;**<u>Q1. 计数排序的局限性 ？**</u>
&emsp;&emsp;&emsp;1.当数列最大最小值差距过大时，并不适用计数排序
&emsp;&emsp;&emsp;2,.当数列元素不是整数时，不适用计数排序。
&emsp; &emsp;计数排序的原理如下：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200318112747889.png)</div>
```
vector<int> countSort(vector<int> &data){
    int mind=INT_MAX;
    int maxd=-INT_MAX;
    for(int i=0;i<data.size();i++){
        if(data[i]>maxd)
            maxd=data[i];   //获取最大值
        if(data[i]<mind)
            mind=data[i];   //获取最小值
    }
    int *countArray=new int[maxd-mind+1];
    for(int i=0;i<data.size();i++)
        countArray[data[i]-mind]++;   //依次放入数组中
    vector<int> ans;
    for(int i=0;i<maxd-mind+1;i++){
        for(int j=0;j<countArray[i];j++)
            ans.push_back(i+mind);		//从数组中按索引顺序和计数个数读取
    }
    return ans;
}
```
💗 **1.2.10 字典排序**
&emsp; &emsp;字典排序就是按照字典中出现的先后顺序进行排序。在计算机中，26个字母及数字字符排序顺序为： `'0' < '1' < '2' < ... < '9' < 'a' < 'b' < ... < 'z'`
 &emsp; &emsp;当给定多个字符时，可以按照任意顺序进行排列，所有排列称为全排列，每一种排列对应一个字符串，如果这些字符串按照字符串大小的顺序进行排序，那么就这种排序是基于字典序的全排列。比如给定三个字符 `a,b,c`，则他们基于字典序的全排列为：`abc > acb > bac > bca > cab > cba`

##### 1.3 如何正确的选择合适的排序算法？
&emsp; &emsp;学会了排序算法，也要学会在不同的场景下如何选择合适的排序算法。
&emsp; &emsp;&emsp;① 当输入数据基本有序时，应该选用**插入排序**。
&emsp; &emsp;&emsp;② 当数据包含大量的重复元素，应该选用**三路快排**，若数据中没有大量重复元素，则可以选用**快速排序**。
&emsp;&emsp;&emsp;③ 当数据的排序范围非常有限时，**计数排序**是一个很好的选择。
&emsp;&emsp;&emsp;④ 若要求排序是稳定的，则可选择**归并排序**。
&emsp;&emsp;&emsp;⑤ 若数据是使用链表存储的，则可选择**归并排序**。
***
####  2. 查找思想
##### 2.1 查找的概念
&emsp; &emsp;查找就是根据给定的某个值，在查找表(符号表)中确定一个其关键字等于给定值的数据结构。查找通常分为查找表(Search Table)和关键(key)两个部分：
&emsp; &emsp;① 查找表(Search Table)：是由同一类型的数据元素构成的**集合**。查找表分为静态查找表(只作查找操作的查找表)和动态查找表(在查找过程中同时插入数据元素或删除已经存在的数据元素)。
&emsp; &emsp;② 关键(Key)：是数据元素中某个数据项的值。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字。对于可以标识多个数据元素的关键字称为次关键字。
&emsp; &emsp;常见的查找方法如下图所示：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314141159848.png)</div>
##### 2.2 常见的查找思想
💗 **2.2.1  顺序表查找**
&emsp; &emsp;顺序表查找最简单的方式就是通过循环进行查找。
```cpp
int sequenceSearch(vector<int> &data,int value){
    for(int i=0;i<data.size();i++){
        if(data[i]==value)
            return i;
    }
    return -1;
}
```
💗 **2.2.2  有序表查找**
&emsp; &emsp; 有序表查找是<font color=orange>基于有序</font>的基础上进行的。
&emsp; &emsp;<font color=green>**1. 折半查找(二分查找)**</font>
&emsp; &emsp;二分查找的前提必须是**关键码有序(数据有序)，且线性表必须采用顺序存储结构**。二分查找的时间复杂度为`O(logn)`。**对于静态查找表很适用，但对频繁执行插入或删除的数据集就不适用了。**
&emsp; &emsp;二分查找变换公式：
$$mid=low+\frac{1}{2}(high-low)$$
```cpp
int binarySearch(vector<int> &data,int value){
    data=sort->quickSort(data);
    int low=0;
    int high=data.size()-1;
    while(low<=high){
        int mid=(high-low)/2+low;   //获取中间值
        if(value<data[mid])
            high=mid-1;
        else if(value>data[mid])
            low=mid+1;
        else
            return mid;
    }
    return -1;
}
```
&emsp; &emsp; **注意**：在使用二分查找的时候，要注意其细节问题，当其边界不同时，会出现不同的结果。如，利用二分查找法寻找数组中某个目标元素的的边界 -- [leetcode34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/)
&emsp; &emsp;<font color=green>**2. 插值查找**</font>
&emsp; &emsp;插值查找是根据**要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法**。插值查找的前提也必须是**关键码有序**，**适用于表长较大，且关键字分布比较均匀的查找表**，但**不适合极端不均匀的数据**。插值查找的时间复杂度为`O(logn)`。
&emsp; &emsp;插值查找变换公式：
$$mid=low+\frac{key-a[low]}{a[high]-a[low]}(high-low) $$
```cpp
int insertSearch(vector<int>& data,int value){
    data=sort->quickSort(data);  
    int low=0;  
    int high=data.size()-1;
    while(low<high){
        int mid=low+(high-low)*(value-data[low])/(data[high]-data[low]);
        if(value<data[mid])
            high=mid-1;
        else if(value>data[mid])
            low=mid+1;
        else
            return mid;
    }
    return -1;
}
```
&emsp; &emsp;<font color=green>**3.线性索引查找**</font>
&emsp; &emsp; 索引就是把一个关键字与它对应的记录相关联的过程。线性索引是将索引项集合组织为线性结构(**索引表**)
&emsp; &emsp;① **稠密索引**：将数据集中每一个记录对应一个索引项，**索引表中是按照关键码有序排列。** 缺点是索引表的长度与数据项的长度相同，当数据量很大时，索引表也会很大。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200115202827264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
&emsp; &emsp;② **分块索引**：把数据集的记录分成若干块，使得**块内无序，块间有序**。时间复杂度为O(n^(1/2))<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200115205308178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
&emsp; &emsp;③ **倒排索引**：索引项由**次关键码**和**记录表号**组成。其中**记录表号存储具有相同次关键码的所有记录的记录号**。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200115212243172.png)</div>
💗 **2.2.3 散列表查找(原理)**
&emsp; &emsp;散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系，使得每个关键字`key`对应一个存储位置`f(key)`。其中对应关系`f`为散列函数(哈希函数)，存储记录的连续空间称为散列表。`key---散列函数 --->索引`
&emsp; &emsp;**散列表最适合求解查找与给定值相等的记录**。如果是对应同一个关键字对应多个记录，或者范围的查找，不适合散列表查找。
&emsp; &emsp;散列表查找通常分为两步：
&emsp; &emsp;&emsp; ① 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
&emsp; &emsp;&emsp; ② 在查找记录时，通过同样的散列函数计算记录的散列地址，并按此散列地址访问该记录。
&emsp; &emsp;因此，散列表中最重要的是**设计散列函数**。减少散列函数的冲突(如：`f(key1)=f(key2)`)<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200805111055953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>&emsp; &emsp; <font color=SlateBlue><u>**Q1.  散列表有哪些构造方法 ？**</u></font>
&emsp; &emsp; <font color=green> ① 直接定址法：</font>取关键字的某个线性函数值作为散列地址，即`f(key)=a*key+b`。**此方法只能使用与关键字较少的情况下。**
&emsp; &emsp; <font color=green>② 数字分析法：</font>抽取关键字中的一部分，并对数据进行翻转，位移，叠加等方式来提供一个散列函数，计算散列存储位置。**此方法适合处理关键字位数较大的情况。**(如：1234改成4321，1234改成12+34=46等)
&emsp; &emsp; <font color=green>③ 平方取中法：</font>求取关键字的平方，再抽取平方结果的中间`m`位，作为散列地址。**此方法适合于不知道关键字的分布，而位数不是很大的情况**(如：1234->平方为1522756->取中间3位为227，作为散列地址)
&emsp; &emsp; <font color=green>④ 折叠法：</font>将关键字从左到右分割为位数相等的几部分(最后一部分可以短一些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。**此方法不需要知道关键字的分布，适合关键字位数较多的情况**(如：9876543210->分为四组 987|654|321|0 ->叠加求和 987+654+321+0=1962 -> 求后3位962作为散列地址)
&emsp; &emsp;<font color=red> ⑤ 除留余数法：</font>此方法的散列函数为：`f(key)=key mod p (p≤m)` ，关键是选择合适的`p`。若散列表表长为m，<font color=red> 通常p为小于或等于表长(接近m)的最小质数，或不包含小于20质因子的合数</font>。(说人话就是 选择离散列表长度最近的质数)<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200806150915853.png)</div>
&emsp; &emsp; <font color=green>⑥ 随机数法`f(key)=random(key)`</font>: random是随机函数，当关键字的长度不等时，采用这个方法构造散列函数是合适的。
&emsp; &emsp; <font color=SlateBlue><u>**Q2.  如何处理散列冲突  ？**</u></font>
&emsp; &emsp;无论怎么设置散列函数，都无法避免散列函数的冲突，即`key1≠key2`，却有`f(key1)=f(key2)`。
&emsp; &emsp; <font color=green>① 开放定址法：</font>
&emsp; &emsp; 开放定址法原则就是**一旦发生冲突，就去寻找下一个空的散列地址**。开放地址法主要分为三个类型<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119230244227.png)</div>&emsp;&emsp;● 线性探测法：其公式为`f1(key)=(f(key)+di) mod m (di=1,2,3...,m-1)`。**解决冲突的开放地址法称为线性探测法**，如<u>(以19 01 23 14 55 68 11 86 37为例，`H(key)=key MOD 11`)</u>**有如下处理步骤：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20191118220514297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
&emsp;&emsp; ● 二次探测法：**即增加平方运算不让关键字都聚集在某一块区域**。其公式为`f{key}={f(key)+di} mod m (di=1^2,-1^2,2^2,-2^2,...,q^2,-q^2  q≤m/2)`。如<u>(以19 01 23 14 55 68 11 86 37为例，`H(key)=key MOD 11`)</u>。 在线性探测的基础上，从依次往后遍历变成按照 `±(1²)，±(2²)，±(3²)，±(4²)...`的规律进行探测，在线性探测的基础上。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191118222244714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)
&emsp;&emsp; ● 随机探测法：对位移量`di`采用随机函数得到，称之为随机探测法。
&emsp; &emsp; <font color=green>②  再散列函数法：</font>事先多准备几个散列函数，当出现散列冲突时，就换一个散列函数进行计算。即`f(key)=RHi(key)`，`RHi`为不同的散列函数。
&emsp; &emsp;<font color=green> ③ 链地址法(拉链法)：</font>当出现散列冲突时，将所有为同义词的关键字的记录存储到单链表中，散列表只记录所有同义词子表的头指针。
&emsp; &emsp; <font color=green> ④ 公共溢出区法：</font> 当出现散列冲突时，将冲突的关键字存入公共溢出区，在查找时，首先利用散列函数查找关键字，若查找不到，则在公共溢出区中顺序查找。
💗 **2.2.4 其他查找算法**
&emsp; &emsp; 二叉排序树 BST，二叉平衡树 AVL，多路查找树查找，红黑树，见[数据集合及其结构](https://blog.csdn.net/weixin_42963969/article/details/104839973)。

####  3. 问题解决的基础 -穷举
&emsp; &emsp; 计算机在解决问题的过程是对所有结果进行搜索，穷举的过程，因此常见的问题都可以通过暴力穷举来解决。但是由于计算机的资源有限，问题的穷举会造成内存不足或运行超时，因此就需要算法来提升穷举的效率。对于穷举问题的解决通常有如下算法：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200906162749518.png#pic_center)
#####  3.1 搜索算法
&emsp; &emsp; <font color=red>因为排列组合问题，路径问题需要对元素进穷举，因此搜索算法常用来解决排列组合问题</font>。常见的排列组合问题如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200906164308487.png#pic_center)
&emsp; &emsp; 对于上述问题采用回溯算法是最好的解决方式，下面依次介绍`回溯算法(DFS中的一种特殊应用)`，`DFS`与`BFS`。
&emsp; &emsp; <font color=SlateBlue><u>**Q1.  DFS和BFS都能解决搜索问题，有什么区别  ？**</u></font>
![&emsp; &emsp;](https://img-blog.csdnimg.cn/20200911145917304.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200911164030112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70#pic_center)


######  3.1.1 DFS算法
&emsp; &emsp;  <font color=red>`DFS`算法其本质就是从起始节点开始，找到与起始节点相邻所有状态，并判断状态是否符合设定的条件，如果符合条件，则继续递归进入下一状态。</font><font color=green>当遇到条件不符合时，通过回溯，返回当上一状态，重新选择状态。</font>

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200911154825761.png#pic_center)


```cpp
### 1.DFS算法框架
Notice:
	1. 一次DFS只能是以某一位置为起点的所有“连通域”，如果需要对所有元素求其DFS值，需要在循环中调用DFS算法
void DFS(所有的状态，当前状态，结束条件，路径结果，临时路径){
	if(当前状态满足结束条件)
		return;
	if(当前状态到达终点状态){
		将临时路径加入路径结果;
		return;
	}
	for(当前状态:所有状态){
		if(当前状态符合条件){
			当前状态加入临时路径中;
			DFS(所有的状态，下一状态，结束条件，路径结果，临时路径)
		}
	}
}
```
######  3.1.2 回溯算法
&emsp; &emsp; 回溯算法是DFS算法的一种特殊应用。所谓回溯，<font color=green>即当前状态无法继续进入下一状态时，返回到当前状态的上一状态，然后选择另一条路继续。解决一个回溯问题，其本质是解决一个N叉决策树的问题。</font>
&emsp; &emsp; 在回溯算法中，存在三个必要素：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200906165003445.png#pic_center)
&emsp; &emsp;  ● <font color=green>路径</font>：路径表示已经做出的选择，一般也是最终的计算结果。
&emsp; &emsp; ● <font color=green>状态选择列表</font>：在当前状态下，可以做出的选择，通常通过`for循环`对选择列表进行遍历。
&emsp; &emsp; ●<font color=green> 结束条件</font>：当前状态满足本次路径选择过程时，无法再做出选择时，返回。

&emsp; &emsp;  回溯算法的核心框架如下所示：
```cpp
### 2.回溯算法框架
void backtrack(所有的状态,当前状态,结束条件,路径结果,临时路径,状态访问标记){
	if(当前状态满足结束状态)
		return;
	if(当前状态到达终点状态){
		临时路径加入到路径结果中;
		return;
	}
	for(当前状态:所有的状态){
		将当前状态进行访问标记;
		将当前状态添加到临时路径中;
		backtrack(所有的状态,下一状态,结束条件,路径结果,临时路径,状态访问标记);
		将当前状态从临时路径中删除;
		删除当前状态的访问标记;
	}
}
```
######  3.1.3 BFS算法
&emsp; &emsp; `BFS`算法本质是先从根节点(起始点)处查找，然后一层一层的往下查找。
```cpp
# 3. BFS算法框架
void BFS(){
	定义队列queue
}
```

#####  3.1 动态规划
##### 3.1.1 动态规划的本质
&emsp; &emsp;动态规划的出现是为解决一类<font color=green>多阶段决策问题</font>而产生的。那什么是多阶段决策问题呢 ？如下是一个经典选择路径的问题：<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410113903276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
&emsp; &emsp;从上述问题，可以得到，<font color=red>当一个问题可以按时间顺序分解成若干相互联系的阶段，在每一个阶段都要做出决策，全部过程的决策是一个决策序列。要使整个活动的总体效果达到最优的问题，称为多阶段决策问题。</font> 因此在多阶段决策问题中，有三个要素：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830203337754.png#pic_center)


&emsp; &emsp;① **阶段与状态 - 重叠子问题：**
&emsp; &emsp; ● 阶段：阶段是指，将所给问题的过程，按时间或空间特征分解成若干相互联系的阶段，以便按次序去求每阶段的解。因此阶段存在两个特点，一是“<u>相互联系</u>”，二是“<u>次序</u>”。阶段之间的相互联系就是通过状态和状态转移。在动态规划中，每个阶段的问题都是重复性的问题。
&emsp; &emsp;●  状态：状态是阶段的属性。每个阶段通常包含若干个状态，用以描述问题发展到这个阶段时所处在的一种客观情况。因此，应用动态规划的一个重要条件就是<font color=red>将各阶段按照一定的**次序**排列好之后，下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，即子问题必须相互独立。</font> 这就是**无后效性**。
&emsp; &emsp;**② 决策与策略 - 状态转移方程：**
&emsp; &emsp;●  决策： 当各段的状态取定以后，就可以做出不同的决定，从而确定下一阶段的状态，这种决定称为决策，也可以叫做**状态转移**。决策的目的就是“确定下一阶段的状态”。
&emsp; &emsp;●  策略：各段决策确定后，整个问题的决策序列就构成一个策略。
&emsp; &emsp;**③ 最优化原理 - 最优子结构：**
&emsp; &emsp;无论其初始状态及初始决策如何，其以后诸决策对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略，即动态规划每走一步，得到的都是最优解。 同时可以从子问题的最优结果推出更大规模问题的最优结果。 
##### 3.2 动态规划的设计步骤
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830215204294.png#pic_center)


##### 3.3 动态规划的实现与常见问题
💗 **3.3.1 动态规划的实现方式**
&emsp; &emsp;动态规划有两种等价的实现方法：
&emsp; &emsp;&emsp;① **带备忘的自顶向下方法**：此方法按照递归形式进行，在递归过程中，保存每个子问题的解(通常保存在一个数组或散列表中)。当需要子问题的解时，首先检查是否保存过此解。如果是，则返回保存的值，节省计算时间。否则按正常方式计算子问题。
&emsp;&emsp;&emsp;② **自底向上方法**：此方法需要恰当定义子问题，使的任何子问题都依赖于更小的子问题求解。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830191242275.png#pic_center)
💗 **3.3.2 常见的动态规划问题**
&emsp; &emsp;<font color=green>**1. 编辑距离问题**</font>
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200830215920111.png#pic_center)
&emsp; &emsp; 根据动态规划的设计步骤：
&emsp; &emsp; ① 确定目标 ：该问题的目标是求取最少的描述符 - `min`；
&emsp; &emsp; ② 确定状态：在问题及子问题中，变换的变量为`word1`和`word2`的每个字符，因此每个状态和`word1`和`word2`的字符有关。
&emsp; &emsp; ③ 确定状态转移函数的定义：状态转移函数与状态有关，因此设`dp[i][j]`为状态转移函数，其表示`word1(0,i)`和`word2(0,j)`匹配时的最少操作数。
&emsp; &emsp; ④ 确定每一个状态的下一次状态的变化：每个状态的变化就是对`word1`和`word2`的字符操作，从题中说明了三个基本操作：
&emsp; &emsp;  ● 对`word1`在位置`i`之前插入一个字符 ： `dp[i][j](插入后状态)=dp[i][j-1](插入前状态)+1;` 
&emsp; &emsp;  ● 对`word1`在位置`i`之前删除一个字符 ： `dp[i][j](插入后状态)=dp[i-1][j](插入前状态)+1;` 
&emsp; &emsp;  ● 对`word1`在位置`i`之前替换一个字符 ： `dp[i][j](插入后状态)=dp[i-1][j-1](插入前状态)+1;` 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831092955380.png#pic_center)

&emsp; &emsp; ⑤  确定基本情况，即初始情况
&emsp; &emsp; 初始情况就是当`i=0`或`j=0`时的情况。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831092414230.png#pic_center)
&emsp; &emsp;将上述的5个步骤进行整合，即可得到动态规划的最终结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831094004636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70#pic_center)
&emsp; &emsp;<font color=green>**2. 最长回文子序列问题**</font>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200902210357112.png#pic_center)
&emsp; &emsp; 根据动态规划的设计步骤：
&emsp; &emsp; ① 确定目标：题目要求找到最长的回文子序列 - `max`
&emsp; &emsp; ② 确定状态：由于问题中只有一个字符串，其回文子序列字符串`s`的两个字符`s[i]`和`s[j]`有关。
&emsp; &emsp; ③  确定状态转移函数的定义：设`dp[i][j]`为字符串`s(i,j)`中最长的回文子序列
&emsp; &emsp; ④ 确定每个状态的下一次状态变化：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200902212223986.png#pic_center)
&emsp; &emsp; 我们想知道`dp[i][j]`的结果，假设我们知道子问题`dp[i+1][j-1]`的结果，则：
&emsp; &emsp;   ● `if(s[i]==s[j])`时，则`dp[i][j]=dp[i+1][j-1]+2;`
&emsp; &emsp;  ● 否则，说明`s[i]`和`s[j]`不能同时出现在`s[i..j]`的回文子序列中，那么将`s[i]`和`s[j]`分别加入到`s[i+1,j-1]`中，看哪个产生的回文子序列更长，`dp[i][j]=max(dp[i+1][j]，dp[i][j-1]);`
&emsp; &emsp;  ⑤ 确定基本情况：当字符串s只有一个字符时，一定是回文子序列，即`dp[i][j]=1(i=j)`
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200902214539594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70#pic_center)

&emsp; &emsp;下面以“斐波那契数”问题来介绍动态规划算法是如何得到的。
&emsp; &emsp; 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。`F(0) = 0,   F(1) = 1  F(N) = F(N - 1) + F(N - 2), 其中 N > 1.`斐波那契数的状态转移方程：
$$f(n)=
\begin{cases}
0& \text{n=0 || n=1}\\
f(n-1)+f(n-2)& \text{n>0}
\end{cases}$$
&emsp; &emsp; **step1:** 递归暴力解法：
&emsp; &emsp;递归暴力解法就是根据状态转移方程直接进行计算。
```cpp
class Solution {
public:
    int fib(int N) {
        if(N==0)
            return 0;
        if(N==1||N==2)
            return 1;
        return fib(N-1)+fib(N-2);   //进行递归求解
};
```
&emsp; &emsp; **step2**: 带备忘的自顶向下方法：
&emsp; &emsp; 在递归算法中，斐波那契数问题存在大量的重复计算，为了消除冗余计算，增加一个“备忘录”来记录运算的结果，每次运算之前先读取备忘录，如不存在在进行计算。时间复杂度为`(O(n))`。带备忘录的递归解法是一种<自顶向下>的算法。

```cpp
class Solution {
public:
    int fib(int N) {
        if(N==0)
            return 0;
        vector<int> temp(N+1,0);    //设置一个数组(备忘录)用于存放已经计算过的数
        return helper(temp,N);
    }
    int helper(vector<int> &temp,int N){   
        if(N==1||N==2)
            return 1;
        if(temp[N]!=0)    //如果备忘录中不为0，则说明该数计算过，直接读取计算结果就行
            return temp[N];
        temp[N]=helper(temp,N-1)+helper(temp,N-2);  //备忘录不存在，进行计算
        return temp[N];
    }  
};
```
&emsp; &emsp; **step3**: 非递归的动态规划解法(自底向上方法)：
&emsp; &emsp; 动态规划(dp)算法是一种<自底向上>的算法。动态规划的另一个重要特性是**最优子结构**,所谓最优子结构就是**原问题的解由子问题的最优解构成且子问题间必须互相独立**。

```cpp
class Solution {
public:
    int fib(int N) {
        if(N<2)
            return N;
        int pre=0;int cur=1;
        for(int i=2;i<=N;i++){
            int sum=pre+cur;
            pre=cur;
            cur=sum;
        }
        return cur;
};        
```
&emsp; &emsp;动态规划的实现与当前状态的选取有很大的关系，因此需要认真分析问题。如下是对同一问题选取不同状态进行求解。![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062215291847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)
#####  3.4 常见的动态规划问题
&emsp; &emsp;**<u>(1). 0-1 背包问题 ？**</u>
&emsp; &emsp;给定n个重量为$w_1,w_2,...,w_n$，价值为$v_1,v_2,...,v_n$的物品和容量为C的背包。每个物品只能使用一次求在满足背包容量的情况下，使包内总价值最大。
&emsp; &emsp;**问题分析：**
&emsp; &emsp;假设$F(n,C)$表示将前n个物品放入当前容量为c的背包里，得到的最大的价值。此时有两种选择：
&emsp; &emsp;&emsp; &emsp;① 不放入第n个物品，此时价值为$F(n-1,c)$
&emsp; &emsp;&emsp; &emsp;② 放入第n个物品，此时价值为$v_n+F(n-1,c-w_n)$
&emsp; &emsp;因此，第i个物品的最大价值为：$F(i,c)=max(F(i-1,c),v_i+F(i-1,c-w_i))$

&emsp; &emsp;如有四个物品，$(w,v)=(2,2),(3,4）,(5,3),(5,7)$，背包容量C=10。将其列入表格中。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314224926446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)
```cpp
int backet01(vector<int>& v,vector<int> &w,int capacity){   //动态规划解法
	int dp[capacity+1];
    dp[0]=0;
    for(int i=1;i<=capacity;i++){   初始化数组，得到第1个物品放入背包后的价值
        if(w[0]<=capacity)
            dp[i]=v[0];
        else
            dp[i]=0;
    }
    for(int i=1;i<w.size();i++){    //物品循环
        for(int j=capacity;j>=w[i];j--){		//按照背包容量倒推，直到背包容量=第i个物品的重量
            dp[j]=std::max(dp[j],v[i]+dp[j-w[i]]);   //根据状态方程，计算第i个物品在不同背包容量下的价值
        }
    }
    return dp[capacity];
}
```
&emsp; &emsp;**<u>(2). 找零钱问题(完全背包) ？**</u>
&emsp; &emsp;

&emsp; &emsp;**<u>(3). 台阶问题 ？**</u>
&emsp; &emsp;给定一个高度为n的台阶，每次爬上阶梯需要花费相应的体力，$cost=c_1,c_2...c_n$。在爬阶梯时可以选择一次爬一个或两个阶梯，并通过最低的体力消耗，到达楼层顶部。
&emsp; &emsp;**问题分析：**
&emsp; &emsp;假设$F(i)$为第i个台阶时，总共消耗的体力。因为在爬阶梯时可以选择一次爬一个或两个阶梯，所以有两种情况：
&emsp; &emsp;&emsp; &emsp;① 爬一个台阶时：$F(i)=F(i-1)+cost(i)$
&emsp; &emsp;&emsp; &emsp;② 爬两个台阶时：$F(i)=F(i-2)+cost(i)$
&emsp; &emsp;因此，第i个台阶耗费的体力为$F(i)=min(F(i-1),F(i-2))+cost(i)$
```cpp
int minCostClimbingStairs(vector<int>& cost) {
   if(cost.size()==0)
        return 0;
    int pre=cost[0];   //存放前一次结果
    int current=cost[1];   //存放当前结果
    for(int i=2;i<cost.size();i++){
        int temp=current;
        current=min(pre,current)+cost[i];    //dp[n]=min(dp[n-1],dp[n-2])+cost[n]
        pre=temp;
    }
    return min(current,pre);  //由于最后上楼顶的台阶可以一次一个台阶上去，也可以一次两个台阶上去，取最小值
}
```
***
####  4. 双指针思想
#####  4.1  普通双指针
&emsp; &emsp;双指针主要用于遍历数组(包括字符串)，两个指针指向不同的元素，从而协同完成任务。
&emsp; &emsp;双指针通常分为两类：**快慢指针**和**左右指针**。
&emsp; &emsp;**① 快慢指针**：快慢指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。
&emsp; &emsp;**② 左右指针**：左右指针是指在有序数组中，将指向**最左侧**的索引定义为左指针(left)，**最右侧**的定义为右指针(right)，然后从两头向中间进行数组遍历。<font color=red>左右指针多用于有序数组。</font>
#####  4.2  特殊双指针-滑动窗口
&emsp; &emsp;滑动窗口思想可以用于解决数组/字符串的子元素问题，其可以将嵌套的循环问题转换成单循环问题。滑动窗口包括定长滑动窗口和变长滑动窗口。
#####  4.3 双指针使用步骤
&emsp; &emsp;**Step1:** 确定两个指针的初始位置。
&emsp; &emsp;**Step2:** 确定循环的终止条件，开始循环。
&emsp; &emsp;**Step3:** 在循环内部处理事务，并根据条件对两个指针进行移动。
***
#### 5. 贪心思想

&emsp; &emsp;贪心算法(策略)是指，在对问题求解时，总是做出在**当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，它所做出的**仅仅是在某种意义上的<font color=red>局部最优解**</font>。选择的贪心策略必须具备<font color=red>**无后效性**</font>（即某个状态以后的过程**不会影响以前的状态，只与当前状态有关**）
&emsp; &emsp;**<u>(1). 贪心算法的基本思路 ？**</u>
&emsp; &emsp;&emsp;① 建立数学模型来描述问题
&emsp; &emsp;&emsp;② 把求解的问题分成若干个子问题
&emsp; &emsp;&emsp;③ 对每个子问题求解，得到子问题的局部最优解
&emsp; &emsp;&emsp;④ 把子问题的解局部最优解合成原来问题的一个解

&emsp; &emsp;**<u>(2). 贪心算法 与 动态规划 的相似点和区别 ？**</u>
&emsp; &emsp;&emsp; ① 相同点：都需要通过分解子问题来求解，都需要具有最优子结构。
&emsp; &emsp;&emsp; ② 区别：
&emsp; &emsp;&emsp; ● 贪心算法的每一步的最优解一定包含上一步的最优解，上一步的最优解不作保留。
而动态规划的全局最优解一定包含某个局部最优解，但不一定包含上一步的最优解，因此需要记录之前的所有局部最优解。
&emsp; &emsp;&emsp; ● 如果把所有的子问题看成一棵树的话，贪心算法从根出发，每次向下遍历最优子树即可(通常这个“最优”都是基于当前情况下显而易见的“最优”)，就<font color=green>不需要知道一个节点的所有子树情况，于是构不成一棵完整的树</font>；动态规划则自底向上，从叶子向根，构造子问题的解，<font color=green>对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案.</font>


***
#### 6. 搜索思想
&emsp; &emsp;常用的搜索方法包括：深度优先搜索DFS，广度优先搜索BFS，以及基于DFS的回溯算法。
#####  6.1  深度优先搜索DFS
#####  6.2  回溯算法
&emsp; &emsp;回溯法(back tracking)是一种选优搜索法，按选优条件向前搜索，以达到目标。但**当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择**，满足回溯条件的某个状态的点称为“回溯点”。
&emsp; &emsp;回溯算法的基本框架如下(伪代码)：
```cpp
result=[]; //存放路径结果
function backtrack(路径，选择列表){
	if 满足结束条件：
		result.push_back(路径);
		return;
	for 选择 in 选择列表
		做出当前选择的结果
		backtrack(路径，选择列表)
		撤销当前选择
}
```

&emsp; &emsp;以“八皇后问题”来展示回溯算法。
&emsp; &emsp;在n*n格的国际象棋上摆放八个皇后（棋子），使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。列出所有的摆放情况。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200322100348259.png)</div>
```
bool check(int n,int x,int y,const vector<vector<int>> &board){
    for(int i=0;i<n;i++){   //检查行
        if(board[i][y]==1)
            return false;
    }
    for(int i=x-1,j=y-1;i>=0 && j>=0;i--,j--){  //左对角线检查
        if(board[i][j]==1)
            return false;
    }
      for(int i=x-1,j=y+1;i>=0 && j<=n;i--,j++){  //左对角线检查
        if(board[i][j]==1)
            return false;
    }
    return true;
}
//n为棋盘行数，i为起始行数，cnt为方案数，board为棋盘
void Search::queenFind(int n,int i,int &cnt,vector<vector<int>> &board){
    if(i>7){   //当行数大于7,说明所有的“皇后”都摆放完成
        cnt++;
        cout<<"cnt:"<<cnt<<endl;
        for(int pi=0;pi<n;pi++){
             for(int pj=0;pj<n;pj++){
                if(board[pi][pj]==1)   //打印当前方案
                    cout<<" * ";
                else
                    cout<<" O ";
            }
            cout<<endl;
        }             
        return;
    }
    for(int m=0;m<n;m++){   //列循环
        if(check(n,i,m,board)){     //检查当前位置是否可以摆放
            board[i][m]=1;       //将当前位置置为1
            queenFind(n,i+1,cnt,board);  //通过迭代进行行循环
            board[i][m]=0;  //若从递归中退出，则说明下一位置无法摆放，退回重新选择
        }
    }
}
```

#####  6.2  广度优先搜索BFS
***
#### 7. 递归思想
&emsp; &emsp;递归是一种狭义的函数调用，递归是一种通过将<font color=green>**重复问题**</font>分解为同类的子问题而解决问题的方法，把规模较大的一个问题，分解成规模较小的多个子问题去解决，而每一个子问题又可以继续拆分成多个更小的子问题。当最小的子问题解决后，大问题也随之解决。<div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630150737389.png)</div>
##### 7.1 递归与栈的关系(递归的本质)
&emsp; &emsp;函数的调用是利用栈来实现的，因此函数递归调用的本身就是利用栈解决问题的一种方法。函数调用相当于入栈，函数的返回相当于出栈。
##### 7.2 如何解决递归问题
&emsp; &emsp;递归是一种通过将<font color=green>**重复问题**</font>分解为同类的子问题而解决问题的方法，通俗来说就是程序反复调用自身。
<font color=red>&emsp; &emsp;面对递归问题时需要考虑三个问题：
&emsp; &emsp;&emsp;① **找整个递归的终止条件：递归应该在什么时候结束？
&emsp; &emsp;&emsp;② 找返回值：应该给上一级返回什么信息？
&emsp; &emsp;&emsp;③ 本级递归应该做什么：在这一级递归中，应该完成什么任务？**
&emsp; &emsp;注意：面对递归问题时，不要去想这层函数做了什么，调用自身后的下一层函数又做了什么，这会使递归算法很复杂。</font><div align=center>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405104643442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)</div>
***
####  3. 分治思想
##### 3.1 分治的本质
&emsp; &emsp;分治就是分而治之，把一个复杂的问题分解成很多规模较小的子问题，然后解决这些子问题，把解决的子问题合并起来，则大问题就解决了。因此，在分治思想中，主要就是“**分**”和“**合并**”。
&emsp; &emsp;但是，如何对问题进行“分”，以及针对什么问题使用分治算法是分治思想应用的关键。<font color=red>在分治问题中，有4个特征：
&emsp; &emsp;① 当问题的规模缩小到一定程度就很容易解决；
&emsp; &emsp;② 【前提】该问题可以**分解**成若干个规模较小的**相同**问题，即该问题具有最优子结构性质。
&emsp; &emsp;③ 【关键】利用该问题分解出的子问题的解可以**合并**为该问题的解；
&emsp; &emsp;④ 【效率】该问题分解出的各个子问题之间是相互独立的，即子问题之间不包含公共子问题。</font>
##### 3.2 分治的实现
&emsp; &emsp;分治算法主要包含3个步骤：
&emsp; &emsp;① 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题(因为分解后的问题相同，所以通常采用递归方法)；
&emsp; &emsp;② 解决：若子问题规模较小而容易被解决则直接解，否则继续递归分解。
&emsp; &emsp;③ 合并：将各个子问题的解合并为原问题的解。
